Effective Concurrency
with Go
9 Jun 2018

Loh Siu Yin
Technology Consultant, Beyond Broadcast LLP
siuyin@beyondbroadcast.com

* Why Concurrent Design?

* Where is concurrency appropriate?
.image img/workflow.jpg

* Concurrency plus communication
Concurrency is a way to structure a program by breaking it into pieces that can be executed independently.

Communication is the means to coordinate the independent executions.

(Rob Pike)

* Getting started with concurrent design

Step 1: Think like a human

Scenario: You are given a task to make 1000 copies of a document. How would you handle this job?

*Horrible*solution*: Make 1000 copies on your own.
Time taken: 1000T

Sample *solution*1*: First make 10 copies, then ask 10 workers to make 99 copies each.
Time taken: 10T + 99T = 109T

Sample *solution*2*: Make 10 copies, ask 10 workers to make 9 copies each, have 100 workers make 9 copies each.
Time taken: 10T + 9T + 9T = 28T

1 sequential and 2 *concurrent* designs. Timings assume *parallel* execution.

* Step 2: Remember I/O is expensive and goroutines are cheap

Question: Which is/are good candidates for using concurrency in your code?

A. Sum 1000 numbers

B. Make 1000 REST API calls

Discuss

* Step 3: Communicate well (applies both to humans and machines)

- Where do you get your input from?
- Where do you send your output to?
- Who do you tell when you finish, or when you have an error/problem?
- Are there time limits?
- How are job cancellations communicated? 

* Code examples

* Minimise Costly function/API calls
Initial design -- sequential code:
.play -edit cmd/seq1/main.go /10/,/20/

* Use goroutines
.play -edit cmd/gr1/main.go /10/,/20/

This works but it is not a good design. Why?

Poor communication: Cancellation, Timeouts, Error notification ?

* Error notification and handling
What will happen when the code below is run?
.play -edit cmd/er1/main.go /10/,/20/

* How about closing the channel?
Closing the channel means "no more values to come".

.code cmd/er2/main.go /10/,/15/

* Closing the channel ...
Reads from the channel will immediately return with the channel's zero value.

.play -edit cmd/er2/main.go /15/,/20/

Not good ...

* Let's introduce a channel to tell main a goroutine is finished

.play -edit cmd/er3/main.go /15/,/20/

* Worker code
.code cmd/er3/main.go /10/,/15/

Communication is better now that we have a feedback "done" channel.
A worker uses this channel to signal that he has finished working.
(Run code on previous slide)

How about respecting time limits or timeouts?

* Context package
The go standard library has a context package that will address
timeout needs, cancellation as well as "request scoped data".

.play -edit cmd/ct1/main.go /20/,/30/

Calling cancel() will close channel toCtx.Done in main and all goroutines this context was passed to.

* How context is used in workA goroutine

.code cmd/ct1/main.go /10/,/20/

Too much code ...

* Inner goroutine

ctx.Done() is closed when deadline is passed.
A read from a closed channel will immediately return the channel's zero value.
.code cmd/ct1/main.go /12/,/13/

Experiment with different timeout values. Run 2 slides back.

* Explicit cancellation

*Scenario*: You manage a department. Your boss has assigned you a time-critical task. Must be done ASAP!
You have two workers. The task cannot be split up.
What could you do?

Possible *solution*: Assign both workers the same task.
Accept the earlier finisher.
Must remember to let the late finisher know so that he can stop working!

* Worker code
.code cmd/ct2/main.go /10/,/20/

* Main code
.play -edit cmd/ct2/main.go /20/,/30/

* "Request scoped data"
I read the go docs many times, but ...

Scenario: You maintain an e-commerce application. As part of the shopping workflow, the code retrieves:
- a *price*, given a product id
- nearest store *address*, given a postcode/zipcode

The above requests are written to the application log.
These log entries would be a lot more useful if they also log the requester *user*id*.
This user id is "request scoped data".

* Main code
.play -edit cmd/ct3/main.go /20/,/25/

type MyStruct struct {
S string
}

aStruct := MyStruct{}
aStruct.S = "brown fox"

similarly
key := userIDKey{}

* Main code ...
.code cmd/ct3/main.go /25/,/30/

* Goroutines
.play cmd/ct3/main.go /10/,/20/

Try changing the userID.
(Run 2 slides back)

* Code available at

.link https://github.com/siuyin/present_go_effective_concurrency
